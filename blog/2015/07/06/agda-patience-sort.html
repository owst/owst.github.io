<!DOCTYPE html>
<html lang="en">
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    
      Agda Patience Sort ¬∑ Owen Stephens' Website
    
  </title>

  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="stylesheet" href="/assets/css/code_highlight.css">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600|Droid+Sans+Mono" rel="stylesheet" type="text/css">
</head>

    <body>
        <header>
            <a class="no_style" href="/" text="Home"><h1>Owen Stephens</h1></a>
            <a class="no_style" href="/" text="Home"><h3>Software Engineer</h3></a>
        </header>
        <div class="container">
    <div class="post_nav" markdown="1">
    You can jump back <a href="/">Home</a>, or to the <a href="/#blog">Blog</a>, <a href="/#open-source">Open Source</a> or <a href="/#research">Research</a> sections.

    </div>
    <section>
      <div id="post-header">
          <h2 class="post-title">Agda Patience Sort<a class="header_link" href="#">üîó</a>
</h2>
          <time datetime="2015-07-06T00:00:00+01:00" class="page-date">
              
              6th
              July
              2015
          </time>
      </div>
      <div id="post-contents">
          <p>Having recently decided to <a href="http://learnyouanagda.liamoc.net/">learn myself an Agda</a>, I thought
that implementing a <a href="https://en.wikipedia.org/wiki/Patience_sorting">Patience sort</a> would be a neat example to
try and program.  Having <a href="/blog/2010/11/29/scala-patience-sort.html">already implemented</a> a
<a href="https://www.scala-lang.org/">Scala</a> Patience sort, I was interested to see how I could tighten up
the implementation by using a dependently-typed language such as <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a>.</p>

<p>I‚Äôm going to go reasonably fast when describing my implementation, feel free to
take a look at the same file <a href="https://github.com/owst/agda-patience-sort/blob/master/Patience.agda">on Github</a> if you‚Äôd like to explore
it using the excellent <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.QuickGuideToEditingTypeCheckingAndCompilingAgdaCode">Emacs agda-mode</a>.</p>

<p>First, let‚Äôs define the module, and import a bunch of stuff from the
<a href="https://github.com/agda/agda-stdlib/">standard library</a>.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module Patience where
  open import Relation.Binary using (DecTotalOrder; module DecTotalOrder;
    IsDecTotalOrder; module IsDecTotalOrder; Rel; module IsTotalOrder;
    module IsPartialOrder; module IsPreorder)
  open import Relation.Binary.Core hiding (refl)
  open import Level hiding (_‚äî_ ; suc) renaming (zero to lzero)
  open import Data.Nat using (‚Ñï; z‚â§n; s‚â§s; suc; _+_)
    renaming (decTotalOrder to decTotalOrder‚Ñï; _‚â§_ to _‚â§‚Ñï_)
  open import Data.List using (List; []; _‚à∑_)
  open import Data.Product using (Œ£; _,_; _√ó_)
  open import Function using (_‚àò_)
  open import Data.Sum using (inj‚ÇÅ; inj‚ÇÇ)
  open import Data.Nat.Properties.Simple using (+-suc; +-assoc; +-comm)
  open import Relation.Binary.PropositionalEquality as PropEq
    using (_‚â°_; subst; cong; sym)
  open PropEq.‚â°-Reasoning using (begin_; _‚â°‚ü®_‚ü©_; _‚àé)
</code></pre></div></div>

<p>Now, using a total-ordered set, X, I create a ‚Äúlifted‚Äù data-type that adds a
maximum element to X. I create an ordering on the lifted type (i.e. that
compares all elements as less than the maximum, and otherwise defers to the
underlying ordering), and prove that it is transitive. I could prove other
properties, but do not require them, so save space by not doing so.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  -- A module that will contain a type of ordered "piles", analogous
  -- to piles of cards in Patience (though with the stronger
  -- restriction that piles are ordered by the top element).
  module Piles (dto : DecTotalOrder lzero lzero lzero) where
    open DecTotalOrder dto public renaming (Carrier to X)

    -- Append maximum element to X
    data X‚ä§ : Set where
      ‚ä§ : X‚ä§
      ‚ü¶_‚üß : (x : X) ‚Üí X‚ä§ -- lift an element of X

    -- Define an ordering relation on the resulting type
    data _‚ü¶‚â§‚üß_ : Rel X‚ä§ Level.zero where
      x‚â§‚ä§ : ‚àÄ {x} ‚Üí x ‚ü¶‚â§‚üß ‚ä§
      ‚ü¶_‚üß : ‚àÄ {x y} ‚Üí (x ‚â§ y) ‚Üí ‚ü¶ x ‚üß ‚ü¶‚â§‚üß ‚ü¶ y ‚üß -- lift an ordering on X

    -- Ensure the order is transitive
    ‚ü¶‚â§‚üß-trans : Transitive _‚ü¶‚â§‚üß_
    ‚ü¶‚â§‚üß-trans _ x‚â§‚ä§ = x‚â§‚ä§
    ‚ü¶‚â§‚üß-trans ‚ü¶ p ‚üß ‚ü¶ q ‚üß =  ‚ü¶ trans p q ‚üß
</code></pre></div></div>

<p>We will want to use this lifted type to track the minimum element in a set of
Piles, and we will therefore need to find the minimum of two elements of this
type.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    -- Minimum w.r.t. X‚ä§
    min : X‚ä§ ‚Üí X‚ä§ ‚Üí X‚ä§
    min ‚ä§ x = x
    min x ‚ä§ = x
    min ‚ü¶ x ‚üß ‚ü¶ y ‚üß with total x y
    ... | inj‚ÇÅ x‚â§y = ‚ü¶ x ‚üß
    ... | inj‚ÇÇ y‚â§x = ‚ü¶ y ‚üß
</code></pre></div></div>

<p>We can now define a type of ordered vectors, which records the number of
elements it contains. Notice how we leverage dependent types, taking a proof
object argument that ensures that elements that are <code class="language-plaintext highlighter-rouge">cons</code>d onto the vector are
indeed smaller than the existing head of the vector.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    -- Define a type of bounded, ordered vectors
    data OVec : X‚ä§ ‚Üí ‚Ñï ‚Üí Set where
      Œµ : OVec ‚ä§ 0
      cons : ‚àÄ {t n} ‚Üí (x : X) ‚Üí (‚ü¶ x ‚üß ‚ü¶‚â§‚üß t) ‚Üí OVec t n ‚Üí OVec ‚ü¶ x ‚üß (suc n)
</code></pre></div></div>

<p>Now, using ordered vectors (individual piles), we can define a type representing
a (ordered by top element) set of piles, again tracking the minimum element and
the number of elements in the Piles.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    -- Define a type of bounded, ordered (by head elem) vectors of
    -- (non-empty) OVecs.
    data Piles : X‚ä§ ‚Üí ‚Ñï ‚Üí Set where
      Œµ : Piles ‚ä§ 0
      consP : ‚àÄ{x t n m} ‚Üí OVec ‚ü¶ x ‚üß (suc n) ‚Üí (‚ü¶ x ‚üß ‚ü¶‚â§‚üß t) ‚Üí Piles t m
        ‚Üí Piles ‚ü¶ x ‚üß (suc n + m)
</code></pre></div></div>

<p>Later, we will require a couple of lemmas:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    -- Given a proof of equivalence between two elements of ‚Ñï, we can transform
    -- Piles with one size to the other.
    cong-Piles : ‚àÄ {l} {n m : ‚Ñï} ‚Üí (n ‚â° m) ‚Üí Piles l n  ‚Üí Piles l m
    cong-Piles {l} p fn = subst (Piles l) p fn

    ‚ü¶‚â§‚üß-resp-min : ‚àÄ {x y z} ‚Üí x ‚ü¶‚â§‚üß y ‚Üí x ‚ü¶‚â§‚üß z ‚Üí x ‚ü¶‚â§‚üß (min y z)
    ‚ü¶‚â§‚üß-resp-min x‚â§‚ä§ q = q
    ‚ü¶‚â§‚üß-resp-min ‚ü¶ p ‚üß x‚â§‚ä§ = ‚ü¶ p ‚üß
    ‚ü¶‚â§‚üß-resp-min {_} {‚ü¶ y ‚üß} {‚ü¶ z ‚üß} p q with total y z
    ... | inj‚ÇÅ y‚â§z = p
    ... | inj‚ÇÇ z‚â§y = q
</code></pre></div></div>

<p>And now, we can move onto the meat of the implementation, inserting single
elements, and complete piles into existing (possibly empty) <code class="language-plaintext highlighter-rouge">Piles</code>:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    -- We can insert a single element into existing Piles...
    insertElemPiles : ‚àÄ {l n} ‚Üí (x : X) ‚Üí Piles l n
      ‚Üí Piles (min ‚ü¶ x ‚üß l) (suc n)
    insertElemPiles x Œµ = consP (cons x x‚â§‚ä§ Œµ) x‚â§‚ä§ Œµ
    insertElemPiles x (consP {x‚Ä≤} {t} {n} {m} p x‚Ä≤‚â§t ps) with total x x‚Ä≤
    ... | inj‚ÇÅ x‚â§x‚Ä≤ = consP (cons x ‚ü¶x‚â§x‚Ä≤‚üß p) (‚ü¶‚â§‚üß-trans ‚ü¶x‚â§x‚Ä≤‚üß x‚Ä≤‚â§t) ps
      where
        ‚ü¶x‚â§x‚Ä≤‚üß = ‚ü¶ x‚â§x‚Ä≤ ‚üß
    ... | inj‚ÇÇ x‚Ä≤‚â§x = cong-Piles ‚â°‚Ñï (consP p (‚ü¶‚â§‚üß-resp-min ‚ü¶ x‚Ä≤‚â§x ‚üß x‚Ä≤‚â§t) rec)
      where
        rec = insertElemPiles x ps

        ‚â°‚Ñï : suc (n + suc m) ‚â° suc (suc (n + m))
        ‚â°‚Ñï = cong suc (+-suc n m)

    -- ...and insert a Pile into Piles.
    insertPilePiles : ‚àÄ {x t n m} ‚Üí OVec ‚ü¶ x ‚üß (suc n)
      ‚Üí Piles t m ‚Üí Piles (min ‚ü¶ x ‚üß t) (suc n + m)
    insertPilePiles {t = ‚ä§} p Œµ = consP p x‚â§‚ä§ Œµ
    insertPilePiles {x} {‚ü¶ t ‚üß} {n‚ÇÅ} p (consP {n = n‚ÇÇ} {m = m‚ÇÅ} q x‚â§t‚Ä≤ qs)
      with total x t
    ... | inj‚ÇÅ x‚â§t = consP p ‚ü¶ x‚â§t ‚üß (consP q x‚â§t‚Ä≤ qs)
    ... | inj‚ÇÇ t‚â§x = cong-Piles ‚â°‚Ñï (consP q (‚ü¶‚â§‚üß-resp-min ‚ü¶ t‚â§x ‚üß x‚â§t‚Ä≤) rec)
      where
       rec = insertPilePiles p qs

       -- Since we build the piles in two different ways, we need to
       -- prove that the sizes are equivalent, using this lemma about ‚Ñï.
       permute-suc-xyz : {x y z : ‚Ñï} ‚Üí x + suc (y + z) ‚â° y + suc (x + z)
       permute-suc-xyz {x} {y} {z} =
         begin
          x + suc (y + z)
         ‚â°‚ü® +-suc x (y + z) ‚ü©
          suc (x + (y + z))
         ‚â°‚ü® cong suc (sym (+-assoc x y z)) ‚ü©
         suc ((x + y) + z)
         ‚â°‚ü® cong suc (cong (Œª x ‚Üí x + z) (+-comm x y)) ‚ü©
         suc ((y + x) + z)
         ‚â°‚ü® cong suc (+-assoc y x z) ‚ü©
         suc (y + (x + z))
         ‚â°‚ü® sym (+-suc y (x + z)) ‚ü©
         y + suc (x + z)
         ‚àé

       ‚â°‚Ñï = cong suc (permute-suc-xyz {n‚ÇÇ} {n‚ÇÅ} {m‚ÇÅ})
</code></pre></div></div>

<p>It‚Äôd be nice to use some of <a href="https://personal.cis.strath.ac.uk/conor.mcbride/Pivotal.pdf">Connor McBride‚Äôs ideas</a> to avoid the
Green Slime<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> (i.e. the use of <code class="language-plaintext highlighter-rouge">min</code> in the return types). However, I seem to
require the tight bounds, and didn‚Äôt manage to effectively get rid of the calls
to <code class="language-plaintext highlighter-rouge">min</code>. If you have any ideas or suggestions on this, please get in
contact!</p>

<p>Once we have inserted elements into <code class="language-plaintext highlighter-rouge">Piles</code>, we can remove elements one-by-one,
to obtain an ordered <code class="language-plaintext highlighter-rouge">List</code> of elements. When removing a single element (to
obtain the minimum element and a new <code class="language-plaintext highlighter-rouge">Piles</code>), we have to use a <a href="https://ncatlab.org/nlab/show/dependent+sum+type">dependent-sum
type</a> to encode the fact that the lower bound of the resulting
<code class="language-plaintext highlighter-rouge">Piles</code> is the removed element. We maintain the ordering by pushing any
non-empty vectors back into the <code class="language-plaintext highlighter-rouge">Piles</code> to be consumed in-order.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    -- From any non-empty Piles, we can remove the smallest element, to obtain
    -- a pair of that element, and a one-smaller Piles.
    removeOne : ‚àÄ {l n} ‚Üí Piles l (suc n) ‚Üí X √ó (Œ£ X‚ä§ (Œª l' ‚Üí Piles l' n))
    removeOne (consP (cons x _ xs) _ ps) with xs
    ... | Œµ = x , _ , ps
    ... | cons y q ys = x , _ , insertPilePiles (cons y q ys) ps

    -- By repeatedly removing a single element, we can convert Piles in a List.
    pilesToList : ‚àÄ {l n} ‚Üí Piles l n ‚Üí List X
    pilesToList Œµ = []
    pilesToList {n = suc m} p with removeOne p
    ... | x , _ , ps = x ‚à∑ pilesToList ps
</code></pre></div></div>

<p>When converting an arbitrary list of elements into <code class="language-plaintext highlighter-rouge">Piles</code>, we cannot up-front
 know the lower bound or size of the <code class="language-plaintext highlighter-rouge">Piles</code>, thus we can use an existential
 type to ‚Äúhide‚Äù these values. To create a existential Piles, we repeatedly
 insert the elements of the list, one-by-one:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    -- We can existentially hide the bound and size of Piles...
    data ‚àÉPiles : Set where
      ‚àÉ&lt;_&gt; : ‚àÄ {l n} ‚Üí Piles l n ‚Üí ‚àÉPiles

    -- ...and can convert an arbitrary List into a Piles with unknown bound and
    -- size, by repeatedly inserting one element at a time.
    listToPiles : List X ‚Üí ‚àÉPiles
    listToPiles [] = ‚àÉ&lt; Œµ &gt;
    listToPiles (x ‚à∑ xs) with listToPiles xs
    ... | ‚àÉ&lt; ps &gt; = ‚àÉ&lt; insertElemPiles x ps &gt;
</code></pre></div></div>

<p>Now, Patience sorting is simply defined:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    -- Finally, patience sort is simply creating Piles from an arbitrary List,
    -- before converting back to an (ordered) List.
    patienceSort : List X ‚Üí List X
    patienceSort ls with listToPiles ls
    ... | ‚àÉ&lt; ps &gt; = pilesToList ps
</code></pre></div></div>

<p>And all that remains is to demonstrate some example sortings of natural
numbers. Recall that Piles are parameterised by the (totally-ordered) elements
they contain.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  -- Let's create Piles of ‚Ñï
  module Piles‚Ñï = Piles decTotalOrder‚Ñï

  -- and some test lists.
  xs = Piles‚Ñï.patienceSort (5 ‚à∑ 4 ‚à∑ 3 ‚à∑ 2 ‚à∑ 1 ‚à∑ [])
  ys = Piles‚Ñï.patienceSort []
  zs = Piles‚Ñï.patienceSort (4 ‚à∑ 4 ‚à∑ 1 ‚à∑ 5 ‚à∑ 3 ‚à∑ [])

  sortedXs sortedYs sortedZs : List ‚Ñï
  sortedXs = 1 ‚à∑ 2 ‚à∑ 3 ‚à∑ 4 ‚à∑ 5 ‚à∑ []
  sortedYs = []
  sortedZs = 1 ‚à∑ 3 ‚à∑ 4 ‚à∑ 4 ‚à∑ 5 ‚à∑ []

  -- And check that sorting via patience does the right thing.
  xsOk : xs ‚â° sortedXs
  xsOk = PropEq.refl

  ysOk : ys ‚â° sortedYs
  ysOk = PropEq.refl

  zsOk : zs ‚â° sortedZs
  zsOk = PropEq.refl
</code></pre></div></div>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>Functions are highlighted in Green in Agda. Such functions are ‚Äúopaque‚Äù to Agda when performing unification, and are discouraged from being used in data type indices such as here, hence the term ‚ÄúGreen Slime‚Äù.¬†<a href="#fnref:1" class="reversefootnote" role="doc-backlink">‚Ü©</a></p>
    </li>
  </ol>
</div>

      </div>
    </section>
</div>

    </body>
    
        
            <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.13.0/moment.min.js"></script>
        
            <script type="text/javascript" src="/assets/js/time.js"></script>
        
    
</html>
